era = factor(era, levels = c("1910-1989", "1990-2020")))
# Statistical test comparing eras
era_comparison <- correlations_era %>%
group_by(Gender, offset, era) %>%
summarise(mean_corr = mean(Spearman, na.rm = TRUE),
sd_corr = sd(Spearman, na.rm = TRUE),
.groups = "drop")
# T-tests for each gender/time lag combination
ttest_results <- correlations_era %>%
group_by(Gender, offset) %>%
do(tidy(t.test(Spearman ~ era, data = .))) %>%
ungroup() %>%
mutate(significant = p.value < 0.05)
# Visualization with era comparison
eracomparison <- ggplot(correlations_era, aes(x = base_year, y = Spearman, color = offset)) +
geom_point(alpha = 0.2) +
geom_smooth(method = "loess", span = 0.3, se = FALSE, linewidth = 1) +
geom_vline(xintercept = 1990, linetype = "dashed", color = "gray30") +
facet_wrap(~Gender) +
scale_x_continuous(breaks = seq(1910, 2020, by = 20)) +
scale_y_continuous(limits = c(0.4, 1)) +
labs(
title = "Name Popularity Persistence Has Declined Since 1990",
subtitle = "All gender/time-lag combinations show significantly lower correlations post 1990 (p < 0.001)",
x = "Base Year",
y = "Spearman Rank Correlation",
color = "Years Ahead",
caption = paste("Vertical line marks 1990. Statistical tests confirm significant differences",
"between pre-1990 and post-1990 periods for all comparisons.")
) +
theme_minimal() +
theme(legend.position = "top")
# Print statistical results
print(era_comparison)
print(ttest_results)
# Save the plot
ggsave(
filename = "eracomparison.png",  # change the filename as needed
plot = eracomparison,            # replace with your ggplot object
path = "C:/Users/pmnha/my-new-project/22660348/Question1/Results",
width = 8,
height = 6,
dpi = 300
)
# =======================================================================
library(dplyr)
library(ggplot2)
library(forcats)
# Identify one-time top 25 names
one_hit_wonders <- baby_names %>%
group_by(Name, Gender) %>%
summarise(
total_years = n_distinct(Year),
peak_year = Year[which.max(Count)],
peak_rank = min(rank(-Count, ties.method = "min")),
peak_count = max(Count),
.groups = "drop"
) %>%
filter(total_years == 1) %>%  # Only appeared in one year
arrange(peak_year)
# Analyze by decade
decade_wonders <- one_hit_wonders %>%
mutate(decade = floor(peak_year / 10) * 10) %>%
group_by(decade, Gender) %>%
summarise(
count = n(),
avg_peak_rank = mean(peak_rank),
.groups = "drop"
)
# Simplify the data
plot_data <- decade_wonders %>%
mutate(era = ifelse(decade < 1960, "Traditional (Pre-1960)", "Modern (Post-1960)")) %>%
group_by(Gender, era) %>%
summarise(avg_count = mean(count), .groups = "drop")
# Create clean temporal visualization
fads <- ggplot(decade_wonders, aes(x = decade, y = count, color = Gender)) +
# Vertical era divider
geom_vline(xintercept = 1960, linetype = "dashed", color = "gray60", linewidth = 0.8) +
# Data elements
geom_point(size = 3, alpha = 0.8) +
geom_line(linewidth = 1.2) +
# Era background highlights
# Scales and labels
scale_x_continuous(breaks = seq(1910, 2020, by = 10)) +
scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
scale_color_manual(values = c("#D55E00", "#0072B2")) +
labs(
title = "The Rise of Disposable Baby Names",
subtitle = "One-time top 25 names became 5x more common after 1960",
x = "Decade",
y = "Number of One-Hit Wonder Names",
color = "Gender",
caption = "Dashed line marks 1960 transition point"
) +
theme_minimal(base_size = 13) +
theme(
legend.position = c(0.1, 0.9),
panel.grid.minor = element_blank(),
plot.title = element_text(face = "bold", size = 18),
plot.subtitle = element_text(size = 14, color = "gray30", margin = margin(b = 15)),
axis.text.x = element_text(angle = 45, hjust = 1, size = 11),
axis.title = element_text(size = 13)
)
# Save the plot
ggsave(
filename = "fads.png",  # change the filename as needed
plot = fads,            # replace with your ggplot object
path = "C:/Users/pmnha/my-new-project/22660348/Question1/Results",
width = 8,
height = 6,
dpi = 300
)
# Sample code to analyze regional spikes
state_trends <- baby_names %>%
filter(Name %in% c("Lincoln", "Savannah")) %>% # Politician/Nature-inspired
group_by(State, Year, Name) %>%
summarise(Count = sum(Count), .groups = "drop") %>%
ggplot(aes(x = Year, y = Count, color = State)) +
geom_line() +
facet_wrap(~Name) +
labs(title = "State-Specific Name Adoption Patterns")
state_trends
# Baby Name Trend Analysis with Media Impact
# Optimized version using pacman for package management
# Load all packages using pacman (installs if missing)
if (!require(pacman)) install.packages("pacman")
pacman::p_load(
readr, dplyr, stringr, ggplot2, scales, broom, forcats, lubridate, ggrepel,
ggtext, purrr, tidyr
)
# DATA LOADING ----
data_path <- "C:/Users/pmnha/my-new-project/22660348/Question1/Data/"
results_path <- "C:/Users/pmnha/my-new-project/22660348/Question1/Results/"
# Safe loading function
load_datasets <- function() {
datasets <- list(
baby_names = readRDS(paste0(data_path, "Baby_Names_By_US_State.rds")),
charts = readRDS(paste0(data_path, "charts.rds")),
hbo_credits = readRDS(paste0(data_path, "HBO_credits.rds")),
hbo_titles = readRDS(paste0(data_path, "HBO_titles.rds"))
)
# Verify all datasets loaded
if (any(sapply(datasets, is.null))) {
stop("One or more datasets failed to load. Please check file paths.")
}
datasets
}
# Load all data
data <- load_datasets()
list2env(data, envir = .GlobalEnv)
# CORE ANALYSIS FUNCTIONS ----
calculate_top_names <- function(baby_names) {
baby_names %>%
group_by(Year, Gender, Name) %>%
summarise(Total_Count = sum(Count), .groups = "drop") %>%
arrange(Year, Gender, desc(Total_Count)) %>%
group_by(Year, Gender) %>%
slice_head(n = 25) %>%
mutate(Rank = row_number()) %>%
ungroup()
}
compute_correlation <- function(data, year1, year2, gender) {
df1 <- data %>% filter(Year == year1, Gender == gender) %>% select(Name, Rank)
df2 <- data %>% filter(Year == year2, Gender == gender) %>% select(Name, Rank)
merged <- inner_join(df1, df2, by = "Name", suffix = c("_y1", "_y2"))
if (nrow(merged) >= 5) cor(merged$Rank_y1, merged$Rank_y2, method = "spearman") else NA_real_
}
generate_correlations <- function(top25_data) {
expand.grid(
base_year = unique(top25_data$Year),
offset = 1:3,
Gender = unique(top25_data$Gender)
) %>%
mutate(
compare_year = base_year + offset,
Spearman = pmap_dbl(list(base_year, compare_year, Gender),
~ compute_correlation(top25_data, ..1, ..2, ..3))
)
}
# MEDIA IMPACT ANALYSIS ----
analyze_media_impact <- function(hbo_credits, hbo_titles, baby_names) {
# Extract first names from HBO characters
character_firstnames <- hbo_credits %>%
mutate(firstname = str_extract(character, "^[^ ]+")) %>%
distinct(id, firstname) %>%
inner_join(select(hbo_titles, id, release_year, title), by = "id")
# Pre-filter baby names
baby_names_filtered <- baby_names %>%
filter(Count > 0) %>%
select(Name, Year, Gender, Count) %>%
rename(firstname = Name)
# Calculate impact
character_firstnames %>%
inner_join(baby_names_filtered, by = "firstname", relationship = "many-to-many") %>%
mutate(
time_diff = Year - release_year,
period = case_when(
time_diff < 0 ~ "Pre-release",
between(time_diff, 0, 5) ~ "Post-release",
TRUE ~ "Beyond window"
)
) %>%
group_by(firstname, Gender, title, release_year) %>%
summarise(
pre_release = sum(Count[period == "Pre-release"]),
post_release = sum(Count[period == "Post-release"]),
impact_ratio = (post_release - pre_release) / (pre_release + 1),
.groups = "drop"
) %>%
filter(pre_release < 100, post_release > 100) %>%
arrange(desc(impact_ratio))
}
# VISUALIZATION FUNCTIONS ----
create_name_popularity_plot <- function(correlation_data) {
filtered_data <- correlation_data %>%
filter(!is.na(Spearman)) %>%
mutate(offset = factor(offset, levels = 1:3, labels = c("1 Year Later", "2 Years Later", "3 Years Later")))
ggplot(filtered_data, aes(x = base_year, y = Spearman, color = offset)) +
geom_point(alpha = 0.3, size = 1.5) +
geom_smooth(method = "loess", span = 0.3, se = FALSE, linewidth = 1.2) +
facet_wrap(~Gender, labeller = labeller(Gender = c("F" = "Girls", "M" = "Boys"))) +
scale_x_continuous(breaks = seq(1910, 2020, by = 10),
labels = c("1910", "'20", "'30", "'40", "'50", "'60", "'70", "'80", "'90", "2000", "'10", "'20")) +
scale_y_continuous(limits = c(0.4, 1), breaks = seq(0.4, 1, by = 0.1)) +
scale_color_manual(values = c("#E69F00", "#56B4E9", "#009E73")) +
labs(
title = "Girls' Names Change Faster Than Boys' (1910-2020)",
subtitle = "Three-year rank correlations show 15-20% greater stability in boys' name popularity",
x = "Base Year", y = "Rank Correlation Coefficient",
color = "Years After Base Year:",
caption = "Correlation of 1 = perfect rank maintenance; 0 = no relationship in popularity rankings"
) +
theme_minimal(base_size = 12) +
theme(
legend.position = "top",
panel.grid.minor = element_blank(),
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(face = "bold", size = 14, margin = margin(b = 5)),
plot.subtitle = element_text(size = 11, color = "gray40", margin = margin(b = 10)),
strip.text = element_text(face = "bold", size = 12),
legend.title = element_text(size = 10),
legend.text = element_text(size = 9)
) +
guides(color = guide_legend(override.aes = list(alpha = 1, size = 2)))
}
create_media_impact_plot <- function(impact_data) {
top_data <- impact_data %>%
arrange(desc(impact_ratio)) %>%
head(15) %>%
mutate(
name_label = ifelse(impact_ratio > 1000, paste0("<b>", firstname, "</b>"), firstname),
tier = case_when(
impact_ratio > 5000 ~ "Elite",
impact_ratio > 1000 ~ "High",
TRUE ~ "Notable"
),
Gender = case_when(
Gender == "F" ~ "Female",
Gender == "M" ~ "Male",
TRUE ~ Gender
)
)
ggplot(top_data, aes(x = reorder(name_label, impact_ratio), y = impact_ratio, fill = tier)) +
geom_col(width = 0.8, color = "white", linewidth = 0.3) +
geom_text(aes(label = scales::comma(round(impact_ratio))), hjust = -0.1, size = 3.5, color = "gray30") +
coord_flip() +
facet_grid(Gender ~ ., scales = "free_y", space = "free_y") +
scale_y_continuous(expand = expansion(mult = c(0, 0.2))) +
scale_fill_manual(values = c("Elite" = "#E63946", "High" = "#457B9D", "Notable" = "#A8DADC")) +
labs(
title = "<span style='font-size:18pt'>**HBO Character Names** with Strongest Baby Name Impact</span>",
subtitle = "Separated by child gender | Ratio of post/pre-show name usage",
x = NULL, y = "Impact Ratio (Post/Pre Release)",
caption = "Data: HBO content & US baby names | Analysis: 5-year impact window"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_markdown(margin = margin(b = 8)),
plot.subtitle = element_text(color = "gray40", size = 11),
axis.text.y = element_markdown(),
legend.position = "none",
panel.grid.major.y = element_blank(),
plot.title.position = "plot",
plot.caption = element_text(color = "gray60", size = 9),
strip.text = element_text(face = "bold", size = 11),
panel.spacing = unit(1, "lines")
)
}
# EXECUTE ANALYSIS ----
top25 <- calculate_top_names(baby_names)
correlations <- generate_correlations(top25)
media_impact <- analyze_media_impact(hbo_credits, hbo_titles, baby_names)
Bespoke_Read_Function <- function(data_path, info_path) {
# Load/install packages using pacman
if (!require(pacman)) install.packages("pacman")
pacman::p_load(readxl, readr, dplyr)
# Step 1: Read and prepare the info file
Info_File <- read_excel(info_path) %>%
select(Key, `Column Type`) %>%  # Use only these two columns
rename(column = Key, type = `Column Type`) %>%
mutate(column = tolower(column))  # Ensure consistent case
# Step 2: Read billionaires data column names
billionaires_cols <- names(read_csv(data_path, n_max = 0)) %>%
tolower()  # Match case with Info_File
# Step 3: Create column type specification
col_spec <- list()
for (col in billionaires_cols) {
col_info <- Info_File %>% filter(column == col)
if (nrow(col_info) == 1) {
col_spec[[col]] <- switch(col_info$type,
"String" = col_character(),
"Integer" = col_integer(),
"Float" = col_double(),
col_character()) # default
} else {
warning(paste("Column", col, "not found in Info_File. Defaulting to character."))
col_spec[[col]] <- col_character()
}
}
# Step 4: Read data
billionaires <- read_csv(
data_path,
col_types = do.call(cols, col_spec),
name_repair = "minimal"  # Preserve original column names
)
return(billionaires)
}
#Call the function
billionaires <- Bespoke_Read_Function(
"C:/Users/pmnha/OneDrive/Desktop/Masters 2025_Economics/Datascience/Exam/22660348/Question4/Data/billionaires.csv",
"C:/Users/pmnha/OneDrive/Desktop/Masters 2025_Economics/Datascience/Exam/22660348/Question4/Data/Info_File.xlsx"
)
# Verify column types
glimpse(billionaires)
Bespoke_Read_Function <- function(data_path, info_path) {
# Load/install packages using pacman
if (!require(pacman)) install.packages("pacman")
pacman::p_load(readxl, readr, dplyr)
# Step 1: Read and prepare the info file
Info_File <- read_excel(info_path) %>%
select(Key, `Column Type`) %>%  # Use only these two columns
rename(column = Key, type = `Column Type`) %>%
mutate(column = tolower(column))  # Ensure consistent case
# Step 2: Read billionaires data column names
billionaires_cols <- names(read_csv(data_path, n_max = 0)) %>%
tolower()  # Match case with Info_File
# Step 3: Create column type specification
col_spec <- list()
for (col in billionaires_cols) {
col_info <- Info_File %>% filter(column == col)
if (nrow(col_info) == 1) {
col_spec[[col]] <- switch(col_info$type,
"String" = col_character(),
"Integer" = col_integer(),
"Float" = col_double(),
col_character()) # default
} else {
warning(paste("Column", col, "not found in Info_File. Defaulting to character."))
col_spec[[col]] <- col_character()
}
}
# Step 4: Read data
billionaires <- read_csv(
data_path,
col_types = do.call(cols, col_spec),
name_repair = "minimal"  # Preserve original column names
)
return(billionaires)
}
#Call the function
billionaires <- Bespoke_Read_Function(
"C:/Users/pmnha/OneDrive/Desktop/Masters 2025_Economics/Datascience/Exam/22660348/Question4/Data/billionaires.csv",
"C:/Users/pmnha/OneDrive/Desktop/Masters 2025_Economics/Datascience/Exam/22660348/Question4/Data/Info_File.xlsx"
)
# Verify column types
glimpse(billionaires)
# Dataset name billionaires
library(ggplot2)
billionaires %>%
filter(location.citizenship == "United States",
wealth.how.inherited == "not inherited") %>%
count(year) %>%
ggplot(aes(x = year, y = n)) +
geom_line(color = "#1f77b4", linewidth = 1.5) +
labs(title = "Rise of Self-Made Billionaires in the US (1996–Present)",
x = "Year", y = "Number of Billionaires") +
theme_minimal()
# Create a cleaner version of inheritance types for grouping and plotting
billionaires %>%
filter(location.citizenship == "United States",
!is.na(wealth.how.inherited)) %>%
mutate(inheritance_group = case_when(
wealth.how.inherited == "not inherited" ~ "Not Inherited",
wealth.how.inherited == "father" ~ "Father",
wealth.how.inherited == "spouse/widow" ~ "Spouse/Widow",
grepl("generation", wealth.how.inherited) ~ "Multi-Generational",
TRUE ~ "Other"
)) %>%
count(year, inheritance_group) %>%
ggplot(aes(x = year, y = n, fill = inheritance_group)) +
geom_area(alpha = 0.8) +
labs(
title = "US Billionaires by Wealth Inheritance Type",
x = "Year", y = "Count", fill = "Inheritance Type"
) +
scale_fill_manual(values = c(
"Not Inherited" = "#ff7f0e",
"Father" = "#d62728",
"Spouse/Widow" = "#2ca02c",
"Multi-Generational" = "#9467bd",
"Other" = "#8c564b"
)) +
theme_minimal()
# Load libraries
library(dplyr)
library(ggplot2)
# Prepare the data
bubble_data_year <- billionaires %>%
filter(
location.citizenship == "United States",
wealth.how.inherited %in% c(
"not inherited", "father", "spouse/widow",
"3rd generation", "4th generation", "5th generation or longer"
),
!is.na(wealth.how.industry),
!is.na(year)
) %>%
count(year, wealth.how.inherited, wealth.how.industry, name = "count") %>%
mutate(
highlight = ifelse(wealth.how.inherited == "not inherited", "Not Inherited", "Other"),
x_label = ifelse(wealth.how.inherited == "not inherited", "Not Inherited", "")
)
# Plot
ggplot(bubble_data_year, aes(
x = x_label,
y = wealth.how.industry,
size = count,
color = highlight
)) +
geom_point(alpha = 0.7, show.legend = FALSE) +
scale_color_manual(values = c("Not Inherited" = "#1f77b4", "Other" = "gray80")) +
scale_size_area(max_size = 15) +
facet_wrap(~ year, ncol = 3) +
labs(
title = "Surge of New-Money In the US: Industry Breakdown Over Time (1990s–2010s)",  #need to italic subtitle
subtitle = "Forget trust funds – this is how tech wizards,hedge fund sharks, and disruptors built their billions",
x = "Inheritance Type",
x = "Inheritance Type",
y = "Industry",
size = "Number of Billionaires"
) +
theme_minimal() +
theme(
axis.text.x = element_text(face = "bold", color = "#1f77b4"),
strip.text = element_text(face = "bold")
)
library(dplyr)
library(ggplot2)
library(tidyr)
library(ggthemes)
# Step 1: Reclassify market types with US separate
billionaires <- billionaires %>%
mutate(
wealth_origin_grouped = ifelse(wealth.how.inherited == "not inherited", "Not Inherited", "Inherited"),
market_type_clean = case_when(
location.citizenship == "United States" ~ "United States",
market_type == "Developed Market" ~ "Developed Market (excl. US)",
TRUE ~ market_type
)
)
library(dplyr)
library(ggplot2)
library(forcats)
# Reclassify market type: separate US as before or keep original if you prefer
billionaires <- billionaires %>%
mutate(
market_type_clean = case_when(
location.citizenship == "United States" ~ "United States",
TRUE ~ market_type
),
wealth_origin_grouped = ifelse(`wealth.how.inherited` == "not inherited", "Not Inherited", "Inherited"),
wealth.how.industry_clean = case_when(
# Clean typos or group related industries
grepl("Technology", wealth.how.industry, ignore.case = TRUE) ~ "Technology",
grepl("Consumer", wealth.how.industry, ignore.case = TRUE) ~ "Consumer Services",
grepl("Retail", wealth.how.industry, ignore.case = TRUE) ~ "Retail/Restaurant",
grepl("Real Estate", wealth.how.industry, ignore.case = TRUE) ~ "Real Estate",
grepl("Financial|banking|hedge|venture|private equity|money management", wealth.how.industry, ignore.case = TRUE) ~ "Financial Services",
grepl("Mining|Energy|Industrial|Construction|Metals", wealth.how.industry, ignore.case = TRUE) ~ "Industrial/Mining/Energy",
is.na(wealth.how.industry) ~ "Unknown",
TRUE ~ "Other"
)
)
View(billionaires)
library(dplyr)
library(ggplot2)
library(tidyr)
library(ggthemes)
# Step 1: Reclassify market types with US separate
billionaires <- billionaires %>%
mutate(
wealth_origin_grouped = ifelse(wealth.how.inherited == "not inherited", "Not Inherited", "Inherited"),
market_type_clean = case_when(
location.citizenship == "United States" ~ "United States",
market_type == "Developed Market" ~ "Developed Market (excl. US)",
TRUE ~ market_type
)
)
View(baby_names)
View(baby_names)
View(baby_names)
View(bubble_data_year)
